÷÷÷÷÷÷÷÷÷ پروژه‌ی toDoList

در قدم اول اصلا لازم نیست درگیر پیچیدگی‌های ارتباطی لایه‌ی بکند بشیم. اینکه اصلا سرور داریم، http server هست چیه ، کلا درگیر اینا نمیشیم.فقط درگیر نوشتن functionality ها هستیم.
اصلا اینطوری به قضیه نگاه میکنیم که میخوایم یک cli app بنویسیم که میتونینم از طریق Cli بهش ورودی بدیم و ازش خروجی بخوایم.
-----------------
توجه بشه که موجودیت‌ها بلا استثنا باید id یکتا داشته باشند.
مثلا خیلی ساده بخوایم نگاه کنیم اگه بخوایم id را از کاربر بگیریم، باید پس ذهنمون باشه که id یکتا باشه، لذا به نظر میاد شاید همون ایمیل یا کد ملی اگه از کاربر بگیریم، میتونیم یکی از همینا را بزاریم برای id کاربر، در واقع در id نگرانی ما صرفا یکتا بودن هست، و باید مطمئن باشیم که چیزی که داریم به عنوان id لحاظ میکنیم برای همه ی کاربرها یکتا باشه. 
یک کار جالبتر این هست که مثلا len لیست کاربران + 1 را بزاریم به عنوان ID
-----------------
وقتی registerd را پیاده کردیم و بعد خواستیم لاگین را پیاده کنیم. درک کردیم که یک storage layer نیازمند هستیم. که بالاخره کاربرهایی که  registerd میشن را ذخیره کنیم.
در واقع داریم صرفا تو همون برنامه تو اسلایس میریزیم و وقتی دوباره اجراش میکنیم پاک میشه، خیلی رو مخه. باید یه جا ذخیره‌اش کنیم.
-----------------
استراکت‌هاتون را مثلا استراکت user ترجیحا با حروف بزرگ تعریف کنید، که اون بحث exported را داشته باشیم که پکیج های دیگه هم بتونن از این استراکت استفاده کنند.
-----------------
لیست کاربران را به شکل global در سطح پکیج تعریف کرد، چون خارج از تابع main و توابع دیگه تعریف شده. و لذا همه جا قابل دسترسی هست. اگر با حرف کوچیک تعریف کنیم، فقط داخل پکیجی که تعریفش کردم، قابل دسترس هست، اگر با حرف بزرگ تعریف شد، exported میشه و خارج این پکیج توسط پکیج‌های دیگه هم قابل دسترسی خواهد بود.
-----------------
در هر اسکوپ از جایی که متغیر تعریف میشود تا پایان اون اسکوپ، اون متغیر یا تابع در دسترسی خواهد بود.
-----------------
در چاپ کردن اگر میخوای خودش تایپ را تشخیص بده از v% استفاده کن، و اگر میخوای مثلا اگه تایپ استراکت هست، بیاد اسم فیلدها را بده بیا از v+% استفاده کن.
-----------------
پوینتر به استراکت تعریف کرد، برای اینکه بتونه خالی بودن استراکت را به کمک nil تشخیص بده، در واقع اگه پوینتر به جایی اشاره بکند، دیگه nil نخواهدبود، ولی تا زمانی که کاربری لاگین نکرده و پوینتر به جایی اشاره نمیکند، پوینتر به استراکت nil خواهد بود.
-----------------
هر جا return یا break میخواید بزنید یک خط خالی قبلش بزارید که تو چشم تر باشه.
-----------------
این که اومد کامند و یه تابع جدا براش زد که بعد اگه هم موفق login نشد، return خالی میکرد و از تابع میمد بیرون و ادامش اجرا نمیشد خیلی خوب بود، اگه دقت کنی خودم که داشتم میزدم چون تو main بود نمیتونستم return به کار ببرم مجبور بودم از دستور continue استفاده کنم که برای اونم تازه باید میرفتم شرط و چک میکرد و کلا اضافه کاری بود.
-----------------
نام متغیرها را وابسته به اسکوپشون میتونی تعیین کنی یعنی اگه تو یه اسکوپ کوچیکی تعریف میشن که با چشم قابل رصد کردنه اسم بلندم نزاشتی نزاشتی مثل مثلا i که واسه for loop میزاری البته همین for loop اگه خیلی بلنده و تو بخشهاش هی داری از i استافده میکنی بهتره i بامسماتر باشه، کلا زمان حیات متغیر در اسمش موثره
-----------------



÷÷÷÷÷÷÷÷÷ تمرین‌ها
برای محاسبه‌ی باقی‌مانده هم از % هم از math.Mod میشه استفاده کرد.
-------------------
اگر رشته تماما عددی باشد، داخل if اجرا میشه:
if _, err := strconv.Atoi(ye_string); err == nil {
	pass
}ا
-------------------
خب left-padded zero 
fmt.Sprintf("%02d:%02d", c.Hour, c.Min)
اگر 3 بشه مینویسه 03 اگر 23 باشه همونو مینویسه
-------------------


